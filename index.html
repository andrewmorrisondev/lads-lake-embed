<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>Geolocation with Kalman Filter and Accelerometer</title>
    <style>
        #log {
            font-family: monospace;
            white-space: pre-wrap;
            padding: 10px;
            background-color: #f4f4f4;
            border: 1px solid #ddd;
            height: 300px;
            overflow-y: scroll;
        }
    </style>
</head>
<body>
    <h1>Geolocation and Accelerometer Data</h1>
    <div id="log"></div> <!-- Div to display the logs -->

    <script>
        // Utility function to log messages to the page
        function logMessage(message) {
            const logDiv = document.getElementById('log');
            logDiv.innerHTML += message + '<br>';
            logDiv.scrollTop = logDiv.scrollHeight; // Auto-scroll to the latest log
        }

        // Kalman Filter Class with control input (acceleration data)
        class KalmanFilter {
            constructor({ R, Q, A, B, C }) {
                this.R = R; // Measurement noise
                this.Q = Q; // Process noise
                this.A = A; // State transition matrix
                this.B = B; // Control matrix
                this.C = C; // Measurement matrix
                this.covariance = 1; // Error covariance
                this.value = 0; // Initial value
            }

            // Predict the next state based on control input (acceleration)
            predict(control = 0) {
                this.value = this.A * this.value + this.B * control;
                this.covariance = this.A * this.covariance * this.A + this.Q;
                return this.value;
            }

            // Update the Kalman Filter with a new measurement
            update(measurement) {
                const K = this.covariance * this.C / (this.C * this.covariance * this.C + this.R); // Kalman gain
                this.value = this.value + K * (measurement - this.C * this.value);
                this.covariance = (1 - K * this.C) * this.covariance;
                return this.value;
            }
        }

        // BK FRISBEE positions
        // let frisbeePositions = [[40.6964, -73.9101],[40.6965, -73.9102],[40.6966, -73.9103],[40.6966, -73.9104],[40.6966, -73.9105],[40.6966, -73.9106],[40.6966, -73.9107],[40.6966, -73.9108],[40.6966, -73.9109],[40.6966, -73.9110],[40.6966, -73.9111],[40.6955, -73.9095],[40.6950, -73.9093]]

        // LG FRISBEE positions
        let frisbeePositions = [
            [43.4015, -73.7230],
            [43.40147, -73.72295],
            [43.40144, -73.72290],
            [43.40141, -73.72286],
            [43.40138, -73.72281],
            [43.40135, -73.72276],
            [43.40132, -73.72272],
            [43.40129, -73.72267],
            [43.40126, -73.72262],
            [43.40123, -73.72258],
            [43.40120, -73.72253],
            [43.40117, -73.72249],
            [43.40114, -73.72244]
        ];

        let watchID = null;
        let lastLat = null;
        let lastLon = null;
        let positionBuffer = [];
        let acceleration = { x: 0, y: 0, z: 0 };
        let firstReading = true; // Flag to track the first reading
        const bufferSize = 10;
        const bufferInterval = 200; // Check every 200ms
        const reportInterval = 2000; // Report every 2 seconds

        // Kalman Filter for Latitude and Longitude with control input (acceleration)
        const kalmanLat = new KalmanFilter({ R: 0.01, Q: 0.001, A: 1, B: 1, C: 1 });
        const kalmanLon = new KalmanFilter({ R: 0.01, Q: 0.001, A: 1, B: 1, C: 1 });

        // Function to request motion access for iOS 13+
        function requestMotionAccess() {
            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission()
                .then(response => {
                    if (response === 'granted') {
                        startMotionListener();
                    } else {
                        logMessage('Motion permission not granted');
                    }
                })
                .catch(console.error);
            } else {
                startMotionListener(); // If not iOS or iOS version is < 13
            }
        }

        // Function to start listening to device motion
        function startMotionListener() {
            window.addEventListener('devicemotion', (event) => {
                acceleration.x = event.accelerationIncludingGravity.x || 0;
                acceleration.y = event.accelerationIncludingGravity.y || 0;
                acceleration.z = event.accelerationIncludingGravity.z || 0;
                logMessage(`Acceleration - X: ${acceleration.x}, Y: ${acceleration.y}, Z: ${acceleration.z}`);
            });
        }

        function determineDistanceAndDirection(startPos, endPos) {
            let distAndDirection = { distance: "0", direction: "", giveClue: 'false' };
            let [a, b] = startPos;
            let [x, y] = endPos;
            a *= 364000;
            b *= 364000;
            x *= 364000;
            y *= 364000;
            distAndDirection.distance = Math.floor(Math.sqrt(Math.pow(Math.abs(a - x), 2) + Math.pow(Math.abs(b - y), 2))).toString();

            if (parseInt(distAndDirection.distance) > 20) {
                let ns = "", ew = "";
                if (Math.abs(a - x) > 20 && a < x) { ns = "North" };
                if (Math.abs(b - y) > 20 && b < y) { ew = "East" };
                if (Math.abs(a - x) > 20 && a > x) { ns = "South" };
                if (Math.abs(b - y) > 20 && b > y) { ew = "West" };
                distAndDirection.direction = ns + ew;
            } else {
                distAndDirection.direction = "You Made It";
                distAndDirection.giveClue = 'true';
            }
            return distAndDirection;
        }

        // Function to start watching geolocation
function startWatching() {
    if (navigator.geolocation) {
        if (watchID === null) {
            watchID = navigator.geolocation.watchPosition(
                (position) => {
                    positionBuffer.push({
                        lat: position.coords.latitude,
                        lon: position.coords.longitude,
                        accuracy: position.coords.accuracy
                    });

                    // Keep the buffer size fixed
                    if (positionBuffer.length > bufferSize) {
                        positionBuffer.shift();
                    }
                },
                (error) => {
                    switch (error.code) {
                        case error.PERMISSION_DENIED:
                            logMessage('User denied the request for Geolocation.');
                            break;
                        case error.POSITION_UNAVAILABLE:
                            logMessage('Location information is unavailable.');
                            break;
                        case error.TIMEOUT:
                            logMessage('The request to get user location timed out.');
                            break;
                        case error.UNKNOWN_ERROR:
                            logMessage('An unknown error occurred.');
                            break;
                    }
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,  // Increase timeout to 10 seconds for better accuracy
                    maximumAge: 0    // Ensure fresh location data, no cached values
                }
            );
        } else {
            logMessage('Already watching position.');
        }

        let readingCount = 0;
        const initialFilterLimit = 5; // Reduce Kalman filter effect for the first few readings

        // Set an interval to process the buffer every 2 seconds
        setInterval(() => {
            if (positionBuffer.length === 0) return;

            const avgPosition = positionBuffer.reduce((acc, pos) => {
                acc.lat += pos.lat;
                acc.lon += pos.lon;
                acc.accuracy += pos.accuracy;
                return acc;
            }, {lat: 0, lon: 0, accuracy: 0});

            avgPosition.lat /= positionBuffer.length;
            avgPosition.lon /= positionBuffer.length;
            avgPosition.accuracy /= positionBuffer.length;

            // Ignore updates with poor accuracy
            if (avgPosition.accuracy > 20) {
                logMessage("Position accuracy not sufficient: " + avgPosition.accuracy + " meters");
                return;
            }

            // For the first few readings, bypass or reduce Kalman filter influence
            let filteredLat = avgPosition.lat;
            let filteredLon = avgPosition.lon;

            if (readingCount < initialFilterLimit) {
                filteredLat = avgPosition.lat; // Trust the GPS data more initially
                filteredLon = avgPosition.lon;
                logMessage("First readings - Trusting GPS data.");
            } else {
                // Use Kalman filter to smooth the position
                filteredLat = kalmanLat.update(avgPosition.lat);
                filteredLon = kalmanLon.update(avgPosition.lon);

                // Predict next state based on acceleration
                kalmanLat.predict(acceleration.x);
                kalmanLon.predict(acceleration.y);
            }

            // Skip small position changes if within a threshold
            const latDifference = Math.abs(filteredLat - lastLat);
            const lonDifference = Math.abs(filteredLon - lastLon);
            const minDifference = 0.000001; // Adjust this threshold for your needs

            if (latDifference < minDifference && lonDifference < minDifference) {
                logMessage("Small position change, ignoring...");
                return;
            }

            lastLat = filteredLat;
            lastLon = filteredLon;

            // Create data to send to the parent container
            let data = { user: { latitude: filteredLat, longitude: filteredLon } };
            frisbeePositions.forEach((position, i) => {
                let dataToFrisbee = determineDistanceAndDirection([filteredLat, filteredLon], position);
                dataToFrisbee.latitude = position[0];
                dataToFrisbee.longitude = position[1];
                data[`fris${i + 1}`] = dataToFrisbee;
            });

            // Send the data to the parent container
            window.parent.postMessage(data, '*');
            logMessage("Filtered latitude: " + filteredLat + ", longitude: " + filteredLon);
            logMessage("Data sent to parent: " + JSON.stringify(data));

            readingCount++; // Increment the reading count
        }, reportInterval); // Every 2 seconds
    } else {
        logMessage('Geolocation is not supported by this browser.');
    }
}


        function stopWatching() {
            if (watchID !== null) {
                navigator.geolocation.clearWatch(watchID);
                logMessage('Stopped watching position.');
                watchID = null;
            }
        }

        // Automatically start watching when the iframe loads
        window.onload = () => {
            requestMotionAccess(); // Request access to motion sensors on load
            startWatching();       // Start geolocation tracking
        };
    </script>
</body>
</html>
